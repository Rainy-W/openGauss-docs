# Best Practices of SQL Queries<a name="EN-US_TOPIC_0000001119972378"></a>

Based on the SQL execution mechanism and a large number of practices, SQL statements can be optimized by following certain rules to enable the database to execute SQL statements more quickly and obtain correct results.

-   Replace  **UNION**  with  **UNION ALL**.

    **UNION**  eliminates duplicate rows while merging two result sets but  **UNION ALL**  merges the two result sets without deduplication. Therefore, replace  **UNION**  with  **UNION ALL**  if you are sure that the two result sets do not contain duplicate rows based on the service logic.

-   Add  **NOT NULL**  to the join columns.

    If there are many  **NULL**  values in the  **JOIN**  columns, you can add the filter criterion  **IS NOT NULL**  to filter data in advance to improve the  **JOIN**  efficiency.

-   Replace  **NOT IN**  with  **NOT EXISTS**.

    **Nested Loop Anti Join**  must be used to implement  **NOT IN**, and  **Hash Anti Join**  is required for  **NOT EXISTS**. If no  **NULL**  value exists in the  **JOIN**  columns,  **NOT IN**  is equivalent to  **NOT EXISTS**. Therefore, if you are sure that no  **NULL**  value exists, you can convert  **NOT IN**  to  **NOT EXISTS**  to generate  **hash join**  and to improve the query performance.

    As shown in the following statement, the  **t2.d2**  column does not contain  **NULL**  values \(it is set to  **NOT NULL**\) and  **NOT EXISTS**  is used for the query.

    ```
    select * from t1 where not exists(select * from t2 where t1.c1 = t2.c1);
    ```

    The generated execution plan is as follows:

    ```
    openGauss=# explain select * from t1 where not exists(select * from t2 where t1.c1 = t2.c1);
    QUERY PLAN
    ------------------------------------------------------------------
    Hash Anti Join  (cost=58.35..107.44 rows=1074 width=8)
    Hash Cond: (t1.c1 = t2.c1)
    ->  Seq Scan on t1  (cost=0.00..31.49 rows=2149 width=8)
    ->  Hash  (cost=31.49..31.49 rows=2149 width=4)
    ->  Seq Scan on t2  (cost=0.00..31.49 rows=2149 width=4)
    (5 rows)
    ```

-   Use  **hashagg**.

    If a plan involving  **groupAgg**  and  **SORT**  operations generated by the  **GROUP BY**  statement is poor in performance, you can set  **work\_mem**  to a larger value to generate a  **hashagg**  plan, which does not require sorting and improves the performance.

-   Replace functions with  **CASE**  statements.

    The openGauss performance greatly deteriorates if a large number of functions are called. In this case, you can change the pushdown functions to  **CASE**  statements.

-   Do not use functions or expressions for indexes.

    Using functions or expressions for indexes will stop indexing and enable scanning on the full table.

-   Do not use operators  **!=**,  **<**,  **\>**  ,  **NULL**,  **OR**, or implicit parameter conversion in  **WHERE**  clauses.
-   Split complex SQL statements.

    You can split an SQL statement into several ones and save the execution result to a temporary table if the SQL statement is too complex to be tuned using the solutions above, including but not limited to the following scenarios:

    -   The same subquery is involved in multiple SQL statements of a job and the subquery contains a large amount of data.
    -   Incorrect  **Plan cost**  causes a small hash bucket of subquery. For example, the actual number of rows is 10 million, but only 1000 rows are in hash bucket.
    -   Functions such as  **substr**  and  **to\_number**  cause incorrect measures for subqueries containing a large amount of data.
    -   **BROADCAST**  subqueries are performed on large tables in multi-DN environment.


For details about optimization, see  [Typical SQL Optimization Methods](typical-sql-optimization-methods.md).

