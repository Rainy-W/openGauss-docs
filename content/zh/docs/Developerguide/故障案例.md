# 服务启动失败 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

服务启动失败。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

● 配置参数不合理，数据库集群因系统资源不足，或者配置参数不满足内部约束，启动失败。 

● 由于部分DN实例状态不正常，导致集群启动失败。 

● 目录权限不够。如对/tmp目录、集群数据目录的权限不足。 

● 配置的端口已经被占用。 

● 开启了系统防火墙导致集群启动失败。 

● 组成集群数据库的各台机器之间需要正确建立互信关系，在互信关系出现异常的 情况下，数据库将无法启动。

## 处理办法<a name="section485620163250"></a>

- 确认是否由于参数配置不合理导致系统资源不足或不满足内部约束启动失败。 

  - 登录启动失败的节点，检查运行日志确认是否因资源不足启动失败或配置参 数不满足内部约束。例如出现Out of memory的错误，或

    ```
    FATAL: hot standby is not possible because max_connections = 10 is a lower setting than on the master server (its value was 100)
    ```

  - 检查GUC参数配置的合理性。如，shared_buffers、effective_cache_size、 bulk_write_ring_size等消耗资源过大的参数；或max_connections等不能先 设大再设小的参数。 GUC参数的查看及设置方法，详见《开发者指南》中“配置运行参数”章节。

- 确认是否由于实例状态不正常，导致集群启动失败。 通过gs_om -t status --detail工具，查询当前集群各主备机实例的状态。 

  -  如果某一节点上的所有实例都异常，请参考应急处理中的办法进行主机替 换。 

  - 如果发现某一实例状态为Unknown、Pending和Down的状态，则以集群用户 登录到状态不正常的实例所在节点，查看该实例的日志来检查状态异常的原 因。例如： 

    ```
    2014-11-27 14:10:07.022 CST 140720185366288 FATAL:  database "postgres" does not exist 2014-11-27 14:10:07.022 CST 140720185366288 DETAIL:  The database subdirectory "base/ 13252" is missing.
    ```

    如果日志中出现上面这种报错信息，则说明该DN实例的数据目录文件遭到破坏，该实例无法执行正常查询。需进行替换实例操作。 

- 目录权限不够处理办法。如对/tmp目录、集群数据目录的权限不足。 

  - 根据错误提示，确认是哪个目录的权限不足。 

  - 使用chmod命令修改目录权限使其满足要求。对于/tmp目录，数据库用户需 要具有读写权限。对于集群数据目录，请参考权限无问题的同类目录进行设置。 

- 确认是否由于配置的端口已经被占用，导致集群启动失败。

  - 登录启动失败的节点，查看实例进程是否存在。 

  - 如果实例进程不存在，则可以通过查看该实例的日志来检查启动异常的原因。例如： 

    ```
    2014-10-17 19:38:23.637 CST 139875904172320 LOG:  could not bind IPv4 socket at the 0 time: Address already in use 2014-10-17 19:38:23.637 CST 139875904172320 HINT:  Is another postmaster already running on port 40005? If not, wait a few seconds and retry.
    ```

    如果日志中出现上面这种报错信息，则说明该DN实例的tcp端口已经被占 用，该实例无法正常启动。

    ```
    2015-06-10 10:01:50 CST 140329975478400 [SCTP MODE] WARNING: (sctp bind)         bind(socket=9, [addr:0.0.0.0,port:1024]):Address already in use  --  attempt 10/10 2015-06-10 10:01:50 CST 140329975478400 [SCTP MODE] ERROR: (sctp bind)   Maximum bind() attempts. Die now...
    ```

    如果日志中出现上面这种报错信息，则说明该DN实例的sctp端口已经被占 用，该实例无法正常启动。 

-  通过sysctl -a查看net.ipv4.ip_local_port_range，如果该实例配置的端口在系 统随机占用端口号的范围内，则可以修改系统随机占用端口号的范围，确保 xml文件中所有实例端口号均不在这个范围内。检查某个端口是否被占用的命 令如：netstat -anop | grep 端口号  

  ```
  [root@openGauss36 ~]# netstat -anop | grep 15970
  tcp        0      0 127.0.0.1:15970         0.0.0.0:*               LISTEN      3920251/gaussdb      off (0.00/0/0)
  tcp6       0      0 ::1:15970               :::*                    LISTEN      3920251/gaussdb      off (0.00/0/0)
  unix  2      [ ACC ]     STREAM     LISTENING     197399441 3920251/gaussdb      /tmp/.s.PGSQL.15970
  unix  3      [ ]         STREAM     CONNECTED     197461142 3920251/gaussdb      /tmp/.s.PGSQL.15970
  ```

  

- 确认是否是由于开启了系统防火墙导致集群启动失败。

- 确认是否由于互信关系出现异常，导致集群无法启动。 如果出现类似如下的提示信息，说明集群节点间互信关系出现异常。请重新配置 集群中各台机器的互信关系。 

------

# 出现“Error:No space left on device”提示 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

在集群使用过程中，出现“Error:No space left on device”的提示。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

磁盘空间不足造成此提示信息。

## 处理办法<a name="section485620163250"></a>

- 查看磁盘占用情况。 df -h 显示如下信息，其中Avail列表示各磁盘可用的空间，Use%列表示已使用的磁盘空间 百分比。

  ```
  [root@openeuler123 mnt]# df -h
  Filesystem                  Size  Used Avail Use% Mounted on
  devtmpfs                    255G     0  255G   0% /dev
  tmpfs                       255G   35M  255G   1% /dev/shm
  tmpfs                       255G   57M  255G   1% /run
  tmpfs                       255G     0  255G   0% /sys/fs/cgroup
  /dev/mapper/openeuler-root  196G  8.8G  178G   5% /
  tmpfs                       255G  1.0M  255G   1% /tmp
  /dev/sda2                   9.8G  144M  9.2G   2% /boot
  /dev/sda1                    10G  5.8M   10G   1% /boot/efi
  ```

  由于业务数据的增长情况不同，对剩余磁盘空间的要求不同。建议如下： 

  - 持续观察磁盘空间增长情况，确保剩 余空间满足一年以上的增长要求。 

  - 数据目录所在磁盘已使用空间>60% 则进行空间清理或者扩容。

- 查看数据目录大小。使用如下命令： du --max-depth=1 -h /mnt/ 显示如下信息，其中第一列表示目录或文件的大小，第二列是“/mnt/”目录下的所有子目录或者文件。

  ```
  [root@openGauss36 mnt]# du --max-depth=1 -h /mnt
  83G	/mnt/data3
  71G	/mnt/data2
  365G	/mnt/data1
  518G	/mnt
  ```

- 清理磁盘空间。 建议定期将审计日志备份到其他存储设 备。 pg_log 存放数据库各进程的运 行日志。 建议保留一个月之内的日志。 运行日志可以帮助数据库管理员定位数 据库的问题，如果每日查看错误日志并 及时处理错误，则可以删除这些日志。

- 清理无用的数据。 通过先备份使用频率较低或者一定时间以前的数据到更低成本的存储介质中，然 后清理这些已备份的数据来获取额外的磁盘空间。

- 如果以上步骤无法清理出足够的空间，请联系技术支持工程师扩容磁盘空间。 

  ----结束

------

# 在 XFS 文件系统中，使用 du 命令查询数据文件大小，查询结果较实际文件大小增加  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

在集群使用过程中，如果通过du命令查询数据文件大小，查询结果有可能较实际文件 的大小增加。 du -sh file 假设查询file数据文件的大小。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

XFS文件系统有预分配机制，预分配的大小由参数allocsize确定。du命令显示的文件大 小包括该预分配的磁盘空间。 

## 处理办法<a name="section485620163250"></a>

- XFS文件系统挂载选项allocsize可以选择默认值（64KB）来减缓该问题。 
- 使用du命令时，增加--apparent-size选项，来查看实际文件的大小。 du -sh file --apparent-size 
- XFS文件系统有回收预分配空间的机制，若文件系统回收了某个文件预分配的空 间，则du显示为实际文件的大小。

------

# 在 XFS 文件系统中，出现文件损坏  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

在集群使用过程中，有极小的概率出现XFS文件系统的bug (Input/Output error , structure needs cleaning)。 

## 处理办法<a name="section485620163250"></a>

- 此为XFS文件系统问题。首先可尝试umount/mount对应文件系统，重试看是否规避。若问题重现，则需要参考文件系统相应的文档请系统管理员对文件系统进行修复如xfs_repair）。文件系统成功修复后，请使用gs_ctl build命令来修复文件受损的 DN。 

------

# 对 DN 进行重建过程中重启集群，导致集群启动状态异常  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

在一主多备集群或主备从集群部署模式下，对某一DN进行了重建，在此过程中，重启 集群，该DN状态为Pending Starting，其余DN状态为Pending Need Repair，无法仲 裁出主备，状态为Pending Starting的DN报出大量无法接受业务连接的日志。 

```
redo minRecoveryPoint at 2/321C31C0; backupStartPoint at 1/C13075B0; backupEndRequired FALSE LOG:  redo starts at 1/C5F9D820 LOG:  invalid record length at 2/2170F700: wanted 32, got 0 FATAL:  the database system is starting up FATAL:  the database system is starting up FATAL:  the database system is starting up ...
```

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

- 步骤1 集群启动过程中，所有DN状态是Pending Starting。首先对已有xlog进行REDO，日志 分析发现问题DN已经REDO到了后一条xlog record，依然没有达到ControlFile里的 小恢复点MinRecovery Point

- 步骤2 问题DN在该场景下，无法在REDO过程中通过CheckConsistency检查，无法发信号给 PostMaster主线程，进行PM状态机迁移。 

- 步骤3 集群是以归档恢复模式启动的，由于状态机无法正常迁移，因此DN无法接受连接， CM Agent无法将DN的状态设置成Pending Need Repair。 

- 步骤4 在该问题场景下，CM Server无法仲裁出DN的主备，导致DN的REDO线程一直循环， 无法接收外部业务请求，报错信息显示如下： FATAL : the database system is starting up。 

  ----结束

## 处理办法<a name="section485620163250"></a>

- 步骤1 kill处于Pending Starting状态的DN进程，即剔除DN； 

- 步骤2 等待其他处于Pending Need Repair状态的DN仲裁出主备，恢复到Primary Normal或 Standby Normal状态； 

- 步骤3 对问题DN做全量重建，待其重建成功则问题修复，执行的全量重建命令如下： cm_ctl build -n NODEID -D DATADIR -b full NODEID是节点ID，DATADIR是待重建DN的数据目录。 

  ----结束

------

# switchover操作，主机 demoting hang 住<a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

一主多备模式下，系统资源不足时，发生switchover，出现某个节点主机demoting hang住。

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

当系统资源不足时，无法创建第三方管理线程，导致其管理的子线程无法退出，出现 主机demoting hang住。

## 处理办法<a name="section485620163250"></a>

- 确定为上述场景时执行以下操作，不是上述场景时请勿按照本方法执行。 需要执行以下命令终止主机进程，使备机正常升主。 kill -9 PID 

------

# 磁盘空间达到阈值，数据库只读  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

磁盘空间达到阈值后，设置数据库只读，只允许只读语句执行。

```
执行非只读sql时报错：
ERROR: cannot execute %s in a read-only transaction
或者运行中部分非只读sql（insert、update、create table as、create index、alter table 及copy from等）报错：
canceling statement due to default_transaction_read_only is on.
```

## 处理办法<a name="section485620163250"></a>

- 步骤1 使用maintenance模式连接数据库，以下两种方法均可。

  - 方式一：

    gsql -d postgres -p 8000 -r -m

  - 方式二：

    gsql -d postgres -p 8000 -r

    连接成功后，执行如下命令：

    postgres=# set xc_maintenance_mode=on; 

- 步骤2 使用DROP/TRUNCATE删除当前不再使用的用户表，直至磁盘空间使用率小于设定的 阈值。 

- 步骤3 设置数据库只读模式关闭。 

  ```
  gs_guc reload -D /gaussdb/data/dbnode -c "default_transaction_read_only=off"
  ```

- 步骤4 删除用户表只能暂时缓解磁盘空间不足的问题，建议尽早通过扩容解决磁盘空间不足的问题。

  ----结束

------

# 分析查询语句长时间运行的问题 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

系统中部分查询语句运行时间过长。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

- 查询语句较为复杂，需要长时间运行。 

- 查询语句阻塞

## 处理办法<a name="section485620163250"></a>

- 步骤1 以操作系统用户omm登录主机。 

- 步骤2 使用如下命令连接数据库。 

  gsql -d postgres -p 8000 postgres为需要连接的数据库名称，8000为端口号

- 步骤3 查看系统中长时间运行的查询语句。

  ```
  SELECT timestampdiff(minutes, query_start, current_timestamp) AS runtime, datname, usename, query FROM pg_stat_activity WHERE state != 'idle' ORDER BY 1 desc;
  ```

  查询会返回按执行时间长短从大到小排列的查询语句列表。第一条结果就是当前系统 中执行时间长的查询语句。

  若当前系统较为繁忙，可以通过限制current_timestamp - query_start大于某一阈值来 查看执行时间超过此阈值的查询语句，注意，timestampdiff的第一个参数为时间差单 位，详细请参见《开发者指南》中“SQL参考 > 函数和操作符 > 时间和日期处理函数 和操作符 > TIMESTAMPDIFF”章节章节。例如，超过2分钟的查询语句可以通过以下 语句查询： 

  ```
  SELECT query FROM pg_stat_activity WHERE timestampdiff(minutes, query_start, current_timestamp) > 2;
  ```

- 步骤4 分析长时间运行的查询语句状态

  - 若查询语句处于正常状态，则等待其执行完毕。 

  - 若查询语句阻塞，分析查询语句是否被阻塞中的处理方式。 

    ----结束

------

# 分析查询语句运行状态  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

系统中部分查询语句运行时间过长，通过分析查询语句的运行状态可以确认哪些语句 正在运行，哪些语句被阻塞 

## 处理办法<a name="section485620163250"></a>

- 步骤1 以操作系统用户omm登录主机。 

- 步骤2 使用如下命令连接数据库。 

  gsql -d postgres -p 8000 postgres为需要连接的数据库名称，8000为端口号

- 步骤3 设置参数track_activities为on。 

  SET track_activities = on; 

  当此参数为on时，数据库系统才会收集当前活动查询的运行信息。

- 步骤4 查看正在运行的查询语句

  以查看视图pg_stat_activity为例： 

  ```
  SELECT datname, usename, state, query FROM pg_stat_activity; 
  datname  | usename | state  | query 
  ----------+---------+--------+-------
  postgres | omm     | idle   | 
  postgres | omm     | active | 
  (2 rows) 
  ```

  如果state字段显示为idle，则表明此连接处于空闲，等待用户输入命令。 如果仅需要查看非空闲的查询语句，则使用如下命令查看：

  SELECT datname, usename, state, query FROM pg_stat_activity WHERE state != 'idle';

- 步骤5 分析查询语句为活跃状态还是阻塞状态。通过如下命令查看当前处于阻塞状态的查询语句： 

  SELECT datname, usename, state, query FROM pg_stat_activity WHERE waiting = true; 

  查询结果中包含了当前被阻塞的查询语句，该查询语句所请求的锁资源可能被其他会 话持有，正在等待持有会话释放锁资源.

# 强制结束指定的问题会话  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

有些情况下，为了使系统继续提供服务，管理员需要强制结束有问题的会话 

## 处理办法<a name="section485620163250"></a>

- 步骤1 以操作系统用户omm登录主机。 

- 步骤2 使用如下命令连接数据库。 

  gsql -d postgres -p 8000 

  postgres为需要连接的数据库名称，8000为端口号

- 步骤3 从当前活动会话视图查找问题会话的线程ID。 

  ```
  SELECT datid, pid, state, query FROM pg_stat_activity; 
  
  显示类似如下信息，其中pid的值即为该会话的线程ID。
  datid |       pid       | state  | query 
  -------+-----------------+--------+------ 
  13205 | 139834762094352 | active | 
  13205 | 139834759993104 | idle   | 
  (2 rows) 
  ```

- 步骤4 根据线程ID结束会话。 

  ```
  SELECT pg_terminate_backend(139834762094352);
  
  显示类似如下信息，表示结束会话成功。
  pg_terminate_backend ---------------------
  t
  (1 row)
  
  显示类似如下信息，表示用户正在尝试结束当前会话，此时仅会重连会话，而不是结 束会话。
  FATAL:  terminating connection due to administrator command 
  FATAL:  terminating connection due to administrator command The connection to the server was lost. Attempting reset: Succeeded.
  
  ```

  

# 分析查询语句是否被阻塞<a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

数据库系统运行时，在某些业务场景下，查询语句会被阻塞，导致语句运行时间过长

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

查询语句需要通过加锁来保护其要访问的数据对象。当要进行加锁时发现要访问的数 据对象已经被其他会话加锁，则查询语句会被阻塞，等待其他会话完成操作并释放锁 资源。这些需要加锁访问的数据对象，主要包括表、元组等 。

## 处理办法<a name="section485620163250"></a>

- 步骤1 以操作系统用户omm登录主机。 

- 步骤2 使用如下命令连接数据库。 

  gsql -d postgres -p 8000 

  postgres为需要连接的数据库名称，8000为端口号

- 步骤3 从当前活动会话视图查找问题会话的线程ID。 

  ```
  SELECT w.query AS waiting_query, w.pid AS w_pid, w.usename AS w_user, l.query AS locking_query, l.pid AS l_pid, l.usename AS l_user, t.schemaname || '.' || t.relname AS tablename FROM pg_stat_activity w JOIN pg_locks l1 ON w.pid = l1.pid AND NOT l1.granted JOIN pg_locks l2 ON l1.relation = l2.relation AND l2.granted JOIN pg_stat_activity l ON l2.pid = l.pid JOIN pg_stat_user_tables t ON l1.relation = t.relid WHERE w.waiting = true;
  ```

- 步骤4 根据线程ID结束会话。 

  ```
  SELECT pg_terminate_backend(139834762094352);
  
  显示类似如下信息，表示结束会话成功。
  pg_terminate_backend ---------------------
  t
  (1 row)
  
  显示类似如下信息，表示用户正在尝试结束当前会话，此时仅会重连会话，而不是结 束会话。
  FATAL:  terminating connection due to administrator command 
  FATAL:  terminating connection due to administrator command The connection to the server was lost. Attempting reset: Succeeded.
  ```



# 分析查询效率异常降低的问题   <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

通常在几十毫秒内完成的查询，有时会突然需要几秒的时间完成；而通常需要几秒完 成的查询，有时需要半小时才能完成。如何分析这种查询效率异常降低的问题呢？ ,

## 处理办法<a name="section485620163250"></a>

通过下列的操作步骤，可以分析出查询效率异常降低的原因

- 步骤1 使用analyze命令分析数据库。 analyze命令更新所有表中数据大小以及属性等相关统计信息，建议在作业压力较小时 执行。如果此命令执行后性能恢复或者有所提升，则表明autovacuum未能很好的完成 它的工作，有待进一步分析。 

- 步骤2 检查查询语句是否返回了多余的数据信息。 例如，如果查询语句先查询一个表中所有的记录，而只用到结果中的前10条记录。对 于包含50条记录的表，查询起来是很快的；但是，当表中包含的记录达到50000，查询效率将会有所下降。 若业务应用中存在只需要部分数据信息，但是查询语句却是返回所有信息的情况，建 议修改查询语句，增加LIMIT子句来限制返回的记录数。这样至少使数据库优化器有了 一定的优化空间，一定程度上会提升查询效率。

- 步骤3 检查查询语句单独运行时是否仍然较慢。

  尝试在数据库没有其他查询或查询较少的时候运行查询语句，并观察运行效率。如果 效率较高，则说明可能是由于之前运行数据库系统的主机负载过大导致查询低效。此 外，还可能是由于执行计划比较低效，但是由于主机硬件较快使得查询效率较高。 

- 步骤4 检查重复相同查询语句的执行效率。

  查询效率低的一个重要原因是查询所需信息没有缓存在内存中，这可能是由于内存资 源紧张，缓存信息被其他查询处理覆盖。

  重复执行相同的查询语句，如果后续执行的查询语句效率提升，则可能是由于上述原 因导致。 

----结束

# 执行 SQL 语句时，提示 Lock wait timeout<a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

执行SQL语句时，提示"Lock wait timeout"。 

```
ERROR:  Lock wait timeout: thread 140533638080272 waiting for ShareLock on relation 16409 of database 13218 after 1200000.122 ms ERROR:  Lock wait timeout: thread 140533638080272 waiting for AccessExclusiveLock on relation 16409 of database 13218 after 1200000.193 ms
```

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

数据库中存在锁等待超时现象。 "

## 处理办法<a name="section485620163250"></a>

- 使用gs_clean查看并清理异常的两阶段事务。 

- 数据库在识别此类错误后，会自动进行重跑，重跑次数使用GUC变量 max_query_retry_times来控制。

- 需要分析锁超时的原因，查看pg_locks，pg_stat_activity，两张系统表可以找出超时的SQL语句



# VACUUM FULL一张表后，表文件大小无变化 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

使用VACUUM FULL命令对一张表进行清理，清理完成后表大小和清理前一样大。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

假定该表的名称为table_name，对于该现象可能有以下两种原因： 

- table_name表本身没有delete过数据，使用VACUUM FULL table_name后无需清 理delete的数据。因此表大小清理前后一样大。 

- 在执行VACUUM FULL table_name时有并发的事务存在，可能会导致VACUUM FULL跳过清理那些近删除的数据，导致清理不完全。

## 处理办法<a name="section485620163250"></a>

对于可能原因的第二种情况，给出如下两种处理方法： 

- 如果在VACUUM FULL时有并发的事务存在，此时需要等待所有事务结束，再次 执行VACUUM FULL命令对该表进行清理。 

- 如果使用上面的方法清理后，表文件大小仍然无变化，确认无业务操作后，使用 以下SQL查询活跃事务列表状态： 

  select txid_current(); 

  使用该SQL可以查询当前的事务XID。再使用以下命令查看活跃事务列表： 

  select txid_current_snapshot(); 

  如果发现活跃事务列表中有XID比当前的事务XID小时，

  停止数据库再启动数据库，再次使用VACUUM FULL命令对该表 进行清理。

# 执行表分区操作时，报错<a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

进行ALTER TABLE PARTITION时，收到如下报错：

```
ERROR:start value of partition "XX" NOT EQUAL up-boundary of last partition.
```

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

在同一条ALTER TABLE PARTITION语句中，既存在DROP PARTITION又存在ADD PARTITION时，无论它们的相对顺序是什么，openGauss总会先执行DROP PARTITION再执行ADD PARTITION。执行完DROP PARTITION删除末尾分区后，再执 行ADD PARTITION操作会出现分区间隙，导致报错 

## 处理办法<a name="section485620163250"></a>

为防止出现分区间隙，需要将ADD PARTITION的START值前移。 示例：对于分区表partitiontest 

```
postgres=#  CREATE TABLE partitiontest
(  
c_int integer, 
c_time TIMESTAMP WITHOUT TIME ZONE 
) 
PARTITION BY range (c_int) 
( 
partition p1 start(100)end(108),  
partition p2 start(108)end(120) 
);
使用如下两种语句会发生报错：
postgres=#  ALTER TABLE partitiontest ADD PARTITION p3 start(120)end(130), DROP PARTITION p2; ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition. postgres=#  ALTER TABLE partitiontest DROP PARTITION p2,ADD PARTITION p3 start(120)end(130) ; ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition.
可以修改语句为：
postgres=#  ALTER TABLE partitiontest ADD PARTITION p3 start(108)end(130), DROP PARTITION p2;
postgres=#  ALTER TABLE partitiontest DROP PARTITION p2,ADD PARTITION p3 start(108)end(130) ;

```



# 不同用户查询同表显示数据不同   <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

2个用户登录相同数据库human_resource，分别执行的查询语句如下：select count(*) from areas，查询同一张表areas时，查询结果却不一致。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

- 请先判断同名的表是否确实是同一张表。在关系型数据库中，确定一张表通常需要3个 因素：database，schema，table。从问题现象描述看，database，table已经确定， 分别是human_resource、areas。
- 接着，需要检查schema。使用omm，user01分别登 录发现，search_path依次是public和"$user"。omm作为集群管理员，默认不会创建 omm同名的schema，即不指定schema的情况下所有表都会建在public下。而对于普 通用户如user01，则会在创建用户时，默认创建同名的schema，即不指定schema时 表都会创建在user01的schema下。
- 最终确定该案例发生时，确实因为2个用户之间交 错对表进行操作，导致了同名不同表的情况。 如果判断是同一张表，则需要进一步判断当前该表对象上针对不同的用户存在不用的 访问策略。 

## 处理办法<a name="section485620163250"></a>

对于第一种场景，在操作表时加上schema引用，格式：schema.table。

对于第二种场 景，则属于正常行为，可以通过查询pg_rlspolicy系统表来确认具体的访问准则

# 修改索引只调用索引名提示索引不存在  <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

修改索引只调用索引名提示索引不存在

```
创建分区表索引HR_staffS_p1_index1，不指定索引分区的名称。 
CREATE INDEX HR_staffS_p1_index1 ON HR.staffS_p1 (staff_ID) LOCAL; 
创建分区索引HR_staffS_p1_index2，并指定索引分区的名称。 
CREATE INDEX HR_staffS_p1_index2 ON HR.staffS_p1 (staff_ID) LOCAL 
(   
PARTITION staff_ID1_index,    
PARTITION staff_ID2_index TABLESPACE example3,    
PARTITION staff_ID3_index TABLESPACE example4 
) TABLESPACE example; 
修改索引分区staff_ID2_index的表空间为example1： 
调用“ALTER INDEX HR_staffS_p1_index2 MOVE PARTITION staff_ID2_index TABLESPACE example1;”
提示索引不存在。

```



## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

推测是当前模式是public模式，而不是hr模式，导致检索不到该索引。 

```
使用
ALTER INDEX hr.HR_staffS_p1_index2 MOVE PARTITION staff_ID2_index TABLESPACE example1;
验证推测，发现调用成功。 
接着调用
ALTER SESSION SET CURRENT_SCHEMA TO hr;
再次调用
ALTER INDEX HR_staffS_p1_index2 MOVE PARTITION staff_ID2_index TABLESPACE example1;
发现设置成功。

```



## 处理办法<a name="section485620163250"></a>

在操作表、索引、视图时加上schema引用，格式：schema.table 

# 重建索引失败<a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

当Desc表的索引出现损坏时，无法进行一系列操作，报错信息可能为： 

```
index \"%s\" contains corrupted page at block
 %u" ,RelationGetRelationName(rel),BufferGetBlockNumber(buf), please reindex it.

```

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

在实际操作中，索引会由于软件问题或者硬件问题引起崩溃。例如，当索引分裂完而 磁盘空间不足、出现页面损坏等问题时，会导致索引损坏。 

## 处理办法<a name="section485620163250"></a>

若此表是以pg_cudesc_xxxxx_index进行命名则为列存表，则说明desc表的索引表损 坏，通过desc表的索引表表名，找到对应主表的oid和表，执行REINDEX INTERNAL TABLE name语句重建cudesc表的索引 ]

# 业务运行时整数转换错 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

在转换整数时报出以下错误：

Invalid input syntax for integer: "13."

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

有些数据类型不能转换成目标数据类型。 

## 处理办法<a name="section485620163250"></a>

逐步缩小SQL范围来确定。 



# 高并发报错"too many clients already"或无法创建线程   <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

大并发执行SQL，报错"sorry, too many clients already"；或报无法创建线程、无法 fork进程等错误。 

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

该类报错是由于操作系统线程资源不足引起，查看操作系统ulimit -u，如果过小（如 小于32768），则基本可以判断是操作系统限制引起的。 

## 处理办法<a name="section485620163250"></a>

通过ulimit -u查看操作系统max user processes的值。按如下简易公式计算需要设置的 小值为：value=max(32768， 实例数目*8192)，其中实例数目指本节点所有CN、DN、GTM实 例总数。 

```
[root@openGauss36 mnt]# ulimit -u
unlimited
[root@openGauss36 mnt]#
```

设置方法为，修改/etc/security/limits.conf，追加如下两行：

```
 * hard nproc [value] 
 * soft nproc [value] 
```

对于不同操作系统修改方式略有不同，centos6以上版本可以修改/etc/security/ limits.d/90-nofile.conf文件，方法同上。

另外，也可以直接通过ulimit -u [values]设置，但OS重启会失效，可以添加到全局环 境变量/etc/profile文件中使其生效。

在大并发模式下，建议开启线程池，使数据库内部的线程资源受控。

# btree 索引故障情况下应对策略 <a name="ZH-CN_TOPIC_0244850162"></a>

## 问题现象<a name="zh-cn_topic_0059778167_s7a2ed06fefd0448fae90f40fe4291f8d"></a>

偶发索引丢失错误，报错 

```
ERROR: index 'xxxx_index' contains unexpected zero page
或
ERROR: index 'pg_xxxx_index' contains unexpected zero page”或 “ERROR: compressed data is corrupt
```

## 原因分析<a name="zh-cn_topic_0059778167_s74d2dfcb815b4d8ca504c549a923e5ed"></a>

该类错误是因为索引发生故障导致的。以下为可能引发故障的原因： 

● 由于软件bug或者硬件原因导致的索引不再可用。 

● 索引包含许多空的页面或者几乎为空的页面。 

● 并发执行DDL过程中，发生了网络闪断故障

● 创建并发索引时失败，遗留了一个失效的索引，这样的索引无法被使用。 

● 执行DDL或者DML操作时，网络出现故障。

## 处理办法<a name="section485620163250"></a>

执行REINDEX命令进行索引重建。 

- 步骤1 以操作系统用户omm登录主机。 

- 步骤2 使用如下命令连接数据库。 

  gsql -d postgres -p 8000 -r 

- 步骤3 重建索引。 

  - 如果进行DDL或DML操作时，因软硬件故障导致索引问题，请执行如下方法重建表索引： 

    REINDEX TABLE tablename; 

  - 如果错误提示中是xxxx_index，其中xxxx代表用户表名。请执行如下方法之一重建 表的索引: 

    REINDEX INDEX indexname; 或者 REINDEX TABLE tablename; 

  -  如果错误提示中pg_xxxx_index，说明是系统表索引存在问题。

    请执行如下方法重 建表索引: 

    REINDEX SYSTEM databasename; 

  ----结束