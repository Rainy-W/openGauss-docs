# SELECT<a name="EN-US_TOPIC_0289900232"></a>

## Function<a name="en-us_topic_0283136463_en-us_topic_0237122184_en-us_topic_0059777449_s65596fb5f1d44a428e41dd508d2044a7"></a>

**SELECT**  retrieves data from a table or view.

Serving as an overlaid filter for a database table,  **SELECT**  filters required data from the table using SQL keywords.

## Precautions<a name="en-us_topic_0283136463_en-us_topic_0237122184_en-us_topic_0059777449_s42c37979749545719ac9114594f45d93"></a>

-   You must have the  **SELECT**  permission on each field used in the SELECT statement.

-   **UPDATE**  permission is required when  **FOR UPDATE**  or  **FOR SHARE**  is used.

## Syntax<a name="en-us_topic_0283136463_en-us_topic_0237122184_en-us_topic_0059777449_sb7329222602d46fe944bf6c300931dd2"></a>

-   Query data.

```
[ WITH [ RECURSIVE ] with_query [, ...] ]
SELECT [/*+ plan_hint */] [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
{ * | {expression [ [ AS ] output_name ]} [, ...] }
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY grouping_element [, ...] ]
[ HAVING condition [, ...] ]
[ WINDOW {window_name AS ( window_definition )} [, ...] ]
[ { UNION | INTERSECT | EXCEPT | MINUS } [ ALL | DISTINCT ] select ]
[ ORDER BY {expression [ [ ASC | DESC | USING operator ] | nlssort_expression_clause ] [ NULLS { FIRST | LAST } ]} [, ...] ]
[ LIMIT { [offset,] count | ALL } ]
[ OFFSET start [ ROW | ROWS ] ]
[ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]
[ {FOR { UPDATE | SHARE } [ OF table_name [, ...] ] [ NOWAIT ]} [...] ];
```

>![](public_sys-resources/icon-note.gif) **NOTE:** 
>In condition and expression, you can use the aliases of expressions in  **targetlist**  in compliance with the following rules:
>-   Reference only within the same level.
>-   Only reference aliases in  **targetlist**.
>-   Reference a prior expression in a subsequent expression.
>-   The  **volatile**  function cannot be used.
>-   The  **Window**  function cannot be used.
>-   Aliases cannot be referenced in the  **join on**  condition.
>-   An error is reported if  **targetlist**  contains multiple referenced aliases.

-   The subquery  **with\_query**  is as follows:

    ```
    with_query_name [ ( column_name [, ...] ) ]
        AS ( {select | values | insert | update | delete} )
    ```

-   The specified query source  **from\_item**  is as follows:

    ```
    {[ ONLY ] table_name [ * ] [ partition_clause ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]
    [ TABLESAMPLE sampling_method ( argument [, ...] ) [ REPEATABLE ( seed ) ] ]
    |( select ) [ AS ] alias [ ( column_alias [, ...] ) ]
    |with_query_name [ [ AS ] alias [ ( column_alias [, ...] ) ] ]
    |function_name ( [ argument [, ...] ] ) [ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]
    |function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )
    |from_item [ NATURAL ] join_type from_item [ ON join_condition | USING ( join_column [, ...] ) ]}
    ```

-   The  **group**  clause is as follows:

    ```
    ( )
    | expression
    | ( expression [, ...] )
    | ROLLUP ( { expression | ( expression [, ...] ) } [, ...] )
    | CUBE ( { expression | ( expression [, ...] ) } [, ...] )
    | GROUPING SETS ( grouping_element [, ...] )
    ```

-   The specified partition  **partition\_clause**  is as follows:

    ```
    PARTITION { ( partition_name ) | 
            FOR (  partition_value [, ...] ) }
    ```

    >![](public_sys-resources/icon-note.gif) **NOTE:** 
    >The specified partition applies only to ordinary tables.

-   The sorting order  **nlssort\_expression\_clause**  is as follows:

    ```
    NLSSORT ( column_name, ' NLS_SORT = { SCHINESE_PINYIN_M | generic_m_ci } ' )
    ```

-   Simplified query syntax, equivalent to  **select \* from table\_name**.

    ```
    TABLE { ONLY {(table_name)| table_name} | table_name [ * ]};
    ```


## Parameter Description<a name="en-us_topic_0283136463_en-us_topic_0237122184_en-us_topic_0059777449_sa812f65b8e8c4c638ec7840697222ddc"></a>

-   **WITH \[ RECURSIVE \] with\_query \[, ...\]**

    Specifies one or more subqueries that can be referenced by name in the main query, which is equivalent to a temporary table.

    If  **RECURSIVE**  is specified, it allows a  **SELECT**  subquery to reference itself by name.

    The detailed format of  **with\_query**  is as follows:  **with\_query\_name \[ \(column\_name \[, ...\]\)\] AS \(\{select | values | insert | update | delete\}\)**

    -   **with\_query\_name**  specifies the name of the result set generated by a subquery. Such names can be used to access the result sets of subqueries in a query.
    -   **column\_name**  specifies the column name displayed in the subquery result set.
    -   Each subquery can be a  **SELECT**,  **VALUES**,  **INSERT**,  **UPDATE**  or  **DELETE**  statement.

-   **plan\_hint**  clause

    Follows the  **SELECT**  keyword in the /\*+<_Plan hint_\> \*/ format. It is used to optimize the plan of a  **SELECT**  statement block. For details, see  [Hint-based Tuning](en-us_topic_0283136804.md).

-   **ALL**

    Specifies that all rows that meet the conditions are returned. This is the default behavior and can be omitted.

-   **DISTINCT \[ ON \( expression \[, ...\] \) \]**

    Removes all duplicate rows from the  **SELECT**  result set so one row is kept from each group of duplicates.

    Retains only the first row in the set of rows that have the same result calculated on the given expression.

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >**DISTINCT ON**  expression is explained with the same rule of  **ORDER BY**. Unless you use  **ORDER BY**  to guarantee that the required row appears first, you cannot know what the first row is.

-   **SELECT list**

    Specifies the name of a column in the table to be queried. The value can be a part of the column name or all of the column names. The wildcard \(\*\) is used to represent the column name.

    You may use the  **AS output\_name**  clause to give an alias for an output column. The alias is used for the displaying of the output column. The name, value, and type keywords can be used as column aliases.

    Column names can be expressed in the following formats:

    -   Manually input column names which are spaced using commas \(,\).
    -   Columns computed in the  **FROM**  clause.

-   **FROM clause**

    Specifies one or more source tables for  **SELECT**.

    The  **FROM**  clause can contain the following elements:

    -   table\_name

        Specifies the name of a table or view. The schema name can be added before the table name or view name, for example, schema\_name.table\_name.

    -   alias

        Gives a temporary alias to a table to facilitate the quotation by other queries.

        An alias is used for brevity or to eliminate ambiguity for self-joins. If an alias is provided, it completely hides the actual name of the table.

    -   TABLESAMPLE  _sampling\_method_  \(  _argument_  \[, ...\] \) \[ REPEATABLE \(  _seed_  \) \]

        The  **TABLESAMPLE**  clause following  _table\_name_  specifies that the specified  _sampling\_method_  should be used to retrieve the subset of rows in the table.

        The optional  **REPEATABLE**  clause specifies the number of seeds used to generate random numbers in the sampling method. The seed value can be any non-null constant value. If the table was not changed during the query, the two queries having the same seed and  _argument_  values will select the same sampling in this table. However, different seed values usually generate different samples. If  **REPEATABLE**  is not specified, a new random sample will be selected for each query based on the seed generated by the system.

    -   column\_alias

        Specifies the column alias.

    -   PARTITION

        Queries data in the specified partition in a partitioned table.

    -   partition\_name

        Specifies the name of a partition.

    -   partition\_value

        Specifies the value of the specified partition key. If there are many partition keys, use the  **PARTITION FOR**  clause to specify the value of the only partition key you want to use.

    -   subquery

        Performs a subquery in the  **FROM**  clause. A temporary table is created to save subquery results.

    -   with\_query\_name

        Specifies that the  **WITH**  clause can also be used as the source of the  **FROM**  clause and can be referenced by the name of the  **WITH**  query.

    -   function\_name

        Function name. Function calls can appear in the  **FROM**  clause.

    -   join\_type

        The options are as follows:

        -   \[ INNER \] JOIN

            A  **JOIN**  clause combines two  **FROM**  items. You can use parentheses to determine the order of nesting. In the absence of parentheses,  **JOIN**  nests left-to-right.

            In any case,  **JOIN**  binds more tightly than the commas separating  **FROM**  items.

        -   LEFT \[ OUTER \] JOIN

            Returns all rows that meet join conditions in the Cartesian product, plus those rows that do not match the right table rows in the left table by join conditions. This left-hand row is extended to the full width of the joined table by inserting  **NULL**  values for the right-hand columns. Note that only the  **JOIN**  clause's own condition is considered while the system decides which rows have matches. Outer conditions are applied afterward.

        -   RIGHT \[ OUTER \] JOIN

            Returns all the joined rows, plus one row for each unmatched right-hand row \(extended with  **NULL**  on the left\).

            This is just a notational convenience, since you could convert it to a  **LEFT OUTER JOIN**  by switching the left and right inputs.

        -   FULL \[ OUTER \] JOIN

            Returns all the joined rows, pluses one row for each unmatched left-hand row \(extended with  **NULL**  on the right\), and pluses one row for each unmatched right-hand row \(extended with  **NULL**  on the left\).

        -   CROSS JOIN

            Is equivalent to  **INNER JOIN ON \(TRUE\)**, which means no rows are removed by qualification. These join types are just a notational convenience, since they do nothing you could not do with plain  **FROM**  and  **WHERE**.

            >![](public_sys-resources/icon-note.gif) **NOTE:** 
            >For the  **INNER**  and  **OUTER**  join types, a join condition must be specified, namely exactly one of  **NATURAL ON**,  **join\_condition**, or  **USING \(join\_column \[, ...\]\)**. For  **CROSS JOIN**, none of these clauses can appear.


        **CROSS JOIN**  and  **INNER JOIN**  produce a simple Cartesian product, the same result as you get from listing the two items at the top level of  **FROM**.

    -   ON join\_condition

        Defines which rows have matches in joins. Example: ON left\_table.a = right\_table.a

    -   USING\(join\_column\[, ...\]\)

        ON left\_table.a = right\_table.a AND left\_table.b = right\_table.b ... abbreviation. Corresponding columns must have the same name.

    -   NATURAL

        Is a shorthand for a  **USING**  list that mentions all columns in the two tables that have the same names.

    -   from item

        Specifies the name of the query source object connected.


-   **WHERE clause**

    Forms an expression for row selection to narrow down the query range of  **SELECT**. The condition is any expression that evaluates to a result of Boolean type. Rows that do not satisfy this condition will be eliminated from the output.

    In the  **WHERE**  clause, you can use the operator \(+\) to convert a table join to an outer join. However, this method is not recommended because it is not the standard SQL syntax and may raise syntax compatibility issues during platform migration. There are many restrictions on using the operator \(+\):

    1.  It can appear only in the  **WHERE**  clause.
    2.  If a table join has been specified in the  **FROM**  clause, the operator \(+\) cannot be used in the  **WHERE**  clause.
    3.  The operator \(+\) can work only on columns of tables or views, instead of on expressions.
    4.  If table A and table B have multiple join conditions, the operator \(+\) must be specified in all the conditions. Otherwise, the operator \(+\) will not take effect, and the table join will be converted into an inner join without any prompt information.
    5.  Tables specified in a join condition where the operator \(+\) works cannot cross queries or subqueries. If tables where the operator \(+\) works are not in the  **FROM**  clause of the current query or subquery, an error will be reported. If a peer table for the operator \(+\) does not exist, no error will be reported and the table join will be converted into an inner join.
    6.  Expressions where the operator \(+\) is used cannot be directly connected through  **OR**.
    7.  If a column where the operator \(+\) works is compared with a constant, the expression becomes a part of the join condition.
    8.  A table cannot have multiple foreign tables.
    9.  The operator \(+\) can appear only in the following expressions: comparison, NOT, ANY, ALL, IN, NULLIF, IS DISTINCT FROM, and IS OF. It is not allowed in other types of expressions. In addition, these expressions cannot be connected through  **AND**  or  **OR**.
    10. The operator \(+\) can be used to convert a table join only to a left or right outer join, instead of a full join. That is, the operator \(+\) cannot be specified on both tables of an expression.

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >For the  **WHERE**  clause, if special character  **%**,  **\_**, or  **\\**  is queried in  **LIKE**, add the slash  **\\**  before each character.

-   **GROUP BY clause**

    Condenses query results into a single row all selected rows that share the same values for the grouped expressions.

    -   CUBE \( \{ expression | \( expression \[, ...\] \) \} \[, ...\] \)

        A CUBE grouping is an extension to the GROUP BY clause that creates subtotals for all of the possible combinations of the given list of grouping columns \(or expressions\). In terms of multidimensional analysis, CUBE generates all the subtotals that could be calculated for a data cube with the specified dimensions. For example, given three expressions \(n=3\) in the CUBE clause, the operation results in 2<sup>n</sup>  = 2<sup>3</sup>  = 8 groupings. Rows grouped on the values of  _n_  expressions are called regular rows, and the rest are called superaggregate rows.

    -   GROUPING SETS \( grouping\_element \[, ...\] \)

        Another extension to the  **GROUP BY**  clause. It allows users to specify multiple  **GROUP BY**  clauses. This improves efficiency by trimming away unnecessary data. After you specify the set of groups that you want to create using a  **GROUPING SETS**  expression within a  **GROUP BY**  clause, the database does not need to compute a whole  **ROLLUP**  or  **CUBE**.

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >If the  **SELECT**  list expression quotes some ungrouped fields and no aggregate function is used, an error is displayed. This is because multiple values may be returned for ungrouped fields.

-   **HAVING clause**

    Selects special groups by working with the  **GROUP BY**  clause. The  **HAVING**  clause compares some attributes of groups with a constant. Only groups that matching the logical expression in the  **HAVING**  clause are extracted.

-   **WINDOW clause**

    The general format is  **WINDOW window\_name AS \( window\_definition \) \[, ...\]**.  **window\_name**  is a name can be referenced by  **window\_definition**.  **window\_definition**  can be expressed in the following forms:

    \[ existing\_window\_name \]

    \[ PARTITION BY expression \[, ...\] \]

    \[ ORDER BY expression \[ ASC | DESC | USING operator \] \[ NULLS \{ FIRST | LAST \} \] \[, ...\] \]

    \[ frame\_clause \]

    **frame\_clause**  defines a  **window frame**  for the window function. The window function \(not all window functions\) depends on  **window frame**  and  **window frame**  is a set of relevant rows of the current query row.  **frame\_clause**  can be expressed in the following forms:

    \[ RANGE | ROWS \] frame\_start

    \[ RANGE | ROWS \] BETWEEN frame\_start AND frame\_end

    **frame\_start**  and  **frame\_end**  can be expressed in the following forms:

    UNBOUNDED PRECEDING

    value PRECEDING

    CURRENT ROW

    value FOLLOWING

    UNBOUNDED FOLLOWING

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >For the query of column storage table, only  **row\_number**  window function is supported, and  **frame\_clause**  is not supported.

-   **UNION clause**

    Computes the set union of the rows returned by the involved  **SELECT**  statements.

    The  **UNION**  clause has the following constraints:

    -   By default, the result of  **UNION**  does not contain any duplicate rows unless the  **ALL**  clause is declared.
    -   Multiple  **UNION**  operators in the same  **SELECT**  statement are evaluated left to right, unless otherwise specified by parentheses.
    -   **FOR UPDATE**  cannot be specified either for a  **UNION**  result or for any input of a  **UNION**.

    General expression:

    select\_statement UNION \[ALL\] select\_statement

    -   **select\_statement**  can be any  **SELECT**  statement without an  **ORDER BY**,  **LIMIT**,  **FOR UPDATE**, or  **FOR SHARE**  statement.
    -   **ORDER BY**  and  **LIMIT**  can be attached to the subexpression if it is enclosed in parentheses.

-   **INTERSECT clause**

    Computes the set intersection of rows returned by the involved  **SELECT**  statements. The result of  **INTERSECT**  does not contain any duplicate rows.

    The  **INTERSECT**  clause has the following constraints:

    -   Multiple  **INTERSECT**  operators in the same  **SELECT**  statement are evaluated left to right, unless otherwise specified by parentheses.
    -   Processing  **INTERSECT**  preferentially when  **UNION**  and  **INTERSECT**  operations are executed for results of multiple  **SELECT**  statements.

    General format:

    select\_statement INTERSECT select\_statement

    **select\_statement**  can be any  **SELECT**  statement without a  **FOR UPDATE**  clause.

-   **EXCEPT clause**

    Has the following common form:

    select\_statement EXCEPT \[ ALL \] select\_statement

    **select\_statement**  can be any  **SELECT**  statement without a  **FOR UPDATE**  clause.

    The  **EXCEPT**  operator computes the set of rows that are in the result of the left  **SELECT**  statement but not in the result of the right one.

    The result of  **EXCEPT**  does not contain any duplicate rows unless the  **ALL**  clause is declared. To execute  **ALL**, a row that has  _m_  duplicates in the left table and  _n_  duplicates in the right table will appear MAX\(_m_–_n_, 0\) times in the result set.

    Multiple  **EXCEPT**  operators in the same  **SELECT**  statement are evaluated left to right, unless parentheses dictate otherwise.  **EXCEPT**  binds at the same level as  **UNION**.

    Currently,  **FOR UPDATE**  cannot be specified either for an  **EXCEPT**  result or for any input of an  **EXCEPT**.

-   **MINUS clause**

    Has the same function and syntax as  **EXCEPT**  clause.

-   **ORDER BY clause**

    Sorts data retrieved by  **SELECT**  in descending or ascending order. If the  **ORDER BY**  expression contains multiple columns:

    -   If two columns are equal according to the leftmost expression, they are compared according to the next expression and so on.
    -   If they are equal according to all specified expressions, they are returned in an implementation-dependent order.
    -   Columns sorted by  **ORDER BY**  must be contained in the result retrieved by  **SELECT**.

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >To support Chinese pinyin order or case-insensitive order, specify the  **UTF-8**  or  **GBK**  encoding mode during database initiation. The statements are as follows:
    >initdb –E UTF8 –D ../data –locale=zh\_CN.UTF-8 or initdb –E GBK –D ../data –locale=zh\_CN.GBK

-   **LIMIT clause**

    Consists of two independent sub-clauses:

    LIMIT \{ count | ALL \}

    **OFFSET start count**  specifies the maximum number of rows to return, while  **start**  specifies the number of rows to skip before starting to return rows. When both are specified,  **start**  rows are skipped before starting to count the  **count**  rows to be returned.

-   **OFFSET clause**

    The SQL: 2008 standard has introduced a different clause:

    OFFSET start \{ ROW | ROWS \}

    **start**  specifies the number of rows to skip before starting to return rows.

-   **FETCH \{ FIRST | NEXT \} \[ count \] \{ ROW | ROWS \} ONLY**

    If  **count**  is omitted in a  **FETCH**  clause, it defaults to  **1**.

-   **FOR UPDATE clause**

    Locks rows retrieved by  **SELECT**. This ensures that the rows cannot be modified or deleted by other transactions until the current transaction ends. That is, other transactions that attempt  **UPDATE**,  **DELETE**, or  **SELECT FOR UPDATE**  of these rows will be blocked until the current transaction ends.

    To avoid waiting for the committing of other transactions, you can apply  **NOWAIT**. Rows to which  **NOWAIT**  applies cannot be immediately locked. After  **SELECT FOR UPDATE NOWAIT**  is executed, an error is reported.

    **FOR SHARE**  behaves similarly, except that it acquires a shared rather than exclusive lock on each retrieved row. A share lock blocks other transaction from performing  **UPDATE**,  **DELETE**, or  **SELECT FOR UPDATE**  on these rows, but it does not prevent them from performing  **SELECT FOR SHARE**.

    If specified tables are named in  **FOR UPDATE**  or  **FOR SHARE**, then only rows coming from those tables are locked. Any other tables used in  **SELECT**  are simply read as usual. Otherwise, locking all tables in the statement.

    If  **FOR UPDATE**  or  **FOR SHARE**  is applied to a view or sub-query, it affects all tables used in the view or sub-query.

    Multiple  **FOR UPDATE**  and  **FOR SHARE**  clauses can be written if it is necessary to specify different locking behaviors for different tables.

    If the same table is mentioned \(or implicitly affected\) by both  **FOR UPDATE**  and  **FOR SHARE**  clauses, it is processed as  **FOR UPDATE**. Similarly, a table is processed as  **NOWAIT**  if that is specified in any of the clauses affecting it.

    >![](public_sys-resources/icon-notice.gif) **NOTICE:** 
    >The query of column-store tables does not support  **for update/share**.

-   **NLS\_SORT**

    Specifies that a field is sorted in a special order. Currently, only Chinese Pinyin and case-insensitive sorting are supported.

    Value range:

    -   **SCHINESE\_PINYIN\_M**, sorted by Pinyin order. To use this sort method, specify  **GBK**  as the encoding format when you create the database. If you do not do so, this value is invalid.
    -   **generic\_m\_ci**, case-insensitive order.

-   **PARTITION clause**

    Queries data in the specified partition in a partitioned table.


## Examples<a name="en-us_topic_0283136463_en-us_topic_0237122184_en-us_topic_0059777449_sc1b5e63c90c946b89430696c38fc86c0"></a>

```
-- Obtain the temp_t temporary table by a subquery and query all records in this table.
postgres=# WITH temp_t(name,isdba) AS (SELECT usename,usesuper FROM pg_user) SELECT * FROM temp_t;

-- Query all r_reason_sk records in the tpcds.reason table and delete duplicate records.
postgres=# SELECT DISTINCT(r_reason_sk) FROM tpcds.reason;

-- Example of a LIMIT clause: Obtain a record from the table.
postgres=# SELECT * FROM tpcds.reason LIMIT 1;

-- Query all records and sort them in alphabetic order.
postgres=# SELECT r_reason_desc FROM tpcds.reason ORDER BY r_reason_desc;

-- Use table aliases to obtain data from the pg_user and pg_user_status tables:
postgres=# SELECT a.usename,b.locktime FROM pg_user a,pg_user_status b WHERE a.usesysid=b.roloid;

-- Example of the FULL JOIN clause: Join data in the pg_user and pg_user_status tables.
postgres=# SELECT a.usename,b.locktime,a.usesuper FROM pg_user a FULL JOIN pg_user_status b on a.usesysid=b.roloid;

-- Example of the GROUP BY clause: Filter data based on query conditions, and group the results.
postgres=# SELECT r_reason_id, AVG(r_reason_sk) FROM tpcds.reason GROUP BY r_reason_id HAVING AVG(r_reason_sk) > 25;

-- Example of the GROUP BY CUBE clause: Filter data based on query conditions, and group the results.
postgres=# SELECT r_reason_id,AVG(r_reason_sk) FROM tpcds.reason GROUP BY CUBE(r_reason_id,r_reason_sk);

-- Example of the GROUP BY GROUPING SETS clause: Filter data based on query conditions, and group the results.
postgres=# SELECT r_reason_id,AVG(r_reason_sk) FROM tpcds.reason GROUP BY GROUPING SETS((r_reason_id,r_reason_sk),r_reason_sk);

-- Example of the UNION clause: Merge the names started with W and N in the r_reason_desc column in the tpcds.reason table.
postgres=# SELECT r_reason_sk, tpcds.reason.r_reason_desc
    FROM tpcds.reason
    WHERE tpcds.reason.r_reason_desc LIKE 'W%'
UNION
SELECT r_reason_sk, tpcds.reason.r_reason_desc
    FROM tpcds.reason
    WHERE tpcds.reason.r_reason_desc LIKE 'N%';

-- Example of the NLS_SORT clause: Sort by Chinese Pinyin.
postgres=# SELECT * FROM tpcds.reason ORDER BY NLSSORT( r_reason_desc, 'NLS_SORT = SCHINESE_PINYIN_M');


-- Case-insensitive order:
postgres=# SELECT * FROM tpcds.reason ORDER BY NLSSORT( r_reason_desc, 'NLS_SORT = generic_m_ci');

-- Create a range-partitioned table tpcds.reason_p.
postgres=# CREATE TABLE tpcds.reason_p
(
  r_reason_sk integer,
  r_reason_id character(16),
  r_reason_desc character(100)
)
PARTITION BY RANGE (r_reason_sk)
(
  partition P_05_BEFORE values less than (05),
  partition P_15 values less than (15),
  partition P_25 values less than (25),
  partition P_35 values less than (35),
  partition P_45_AFTER values less than (MAXVALUE)
)
;

-- Insert data.
postgres=# INSERT INTO tpcds.reason_p values(3,'AAAAAAAABAAAAAAA','reason 1'),(10,'AAAAAAAABAAAAAAA','reason 2'),(4,'AAAAAAAABAAAAAAA','reason 3'),(10,'AAAAAAAABAAAAAAA','reason 4'),(10,'AAAAAAAABAAAAAAA','reason 5'),(20,'AAAAAAAACAAAAAAA','reason 6'),(30,'AAAAAAAACAAAAAAA','reason 7');

-- Example of the PARTITION clause: Obtain data from the P_05_BEFORE partition in the tpcds.reason_p table.
postgres=#  SELECT * FROM tpcds.reason_p PARTITION (P_05_BEFORE);
 r_reason_sk |   r_reason_id    |   r_reason_desc                   
-------------+------------------+------------------------------------
           4 | AAAAAAAABAAAAAAA | reason 3                          
           3 | AAAAAAAABAAAAAAA | reason 1                          
(2 rows)

-- Example of the GROUP BY clause: Group records in the tpcds.reason_p table by r_reason_id, and count the number of records in each group.
postgres=# SELECT COUNT(*),r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id;
 count |   r_reason_id    
-------+------------------
     2 | AAAAAAAACAAAAAAA
     5 | AAAAAAAABAAAAAAA
(2 rows)

-- Example of the GROUP BY CUBE clause: Filter data based on query conditions, and group the results.
postgres=# SELECT * FROM tpcds.reason GROUP BY  CUBE (r_reason_id,r_reason_sk,r_reason_desc);

-- Example of the GROUP BY GROUPING SETS clause: Filter data based on query conditions, and group the results.
postgres=# SELECT * FROM tpcds.reason GROUP BY  GROUPING SETS ((r_reason_id,r_reason_sk),r_reason_desc);

-- Example of the HAVING clause: Group records in the tpcds.reason_p table by r_reason_id, count the number of records in each group, and display only values whose number of r_reason_id is greater than 2.
postgres=# SELECT COUNT(*) c,r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id HAVING c>2;
 c |   r_reason_id    
---+------------------
 5 | AAAAAAAABAAAAAAA
(1 row)

-- Example of the IN clause: Group records in the tpcds.reason_p table by r_reason_id, count the number of records in each group, and display only the numbers of records whose r_reason_id is AAAAAAAABAAAAAAA or AAAAAAAADAAAAAAA.
postgres=# SELECT COUNT(*),r_reason_id FROM tpcds.reason_p GROUP BY r_reason_id HAVING r_reason_id IN('AAAAAAAABAAAAAAA','AAAAAAAADAAAAAAA'); 
count |   r_reason_id    
-------+------------------
     5 | AAAAAAAABAAAAAAA
(1 row)

-- Example of the INTERSECT clause: Query records whose r_reason_id is AAAAAAAABAAAAAAA and whose r_reason_sk is smaller than 5.
postgres=# SELECT * FROM tpcds.reason_p WHERE r_reason_id='AAAAAAAABAAAAAAA' INTERSECT SELECT * FROM tpcds.reason_p WHERE r_reason_sk<5;
 r_reason_sk |   r_reason_id    |     r_reason_desc                 
-------------+------------------+------------------------------------
           4 | AAAAAAAABAAAAAAA | reason 3                           
           3 | AAAAAAAABAAAAAAA | reason 1                           
(2 rows)

-- Example of the EXCEPT clause: Query records whose r_reason_id is AAAAAAAABAAAAAAA and whose r_reason_sk is greater than or equal to 4.
postgres=# SELECT * FROM tpcds.reason_p WHERE r_reason_id='AAAAAAAABAAAAAAA' EXCEPT SELECT * FROM tpcds.reason_p WHERE r_reason_sk<4;
r_reason_sk |   r_reason_id    |      r_reason_desc                  
-------------+------------------+------------------------------------
          10 | AAAAAAAABAAAAAAA | reason 2                          
          10 | AAAAAAAABAAAAAAA | reason 5                          
          10 | AAAAAAAABAAAAAAA | reason 4                          
           4 | AAAAAAAABAAAAAAA | reason 3                          
(4 rows)

-- Specify the operator (+) in the WHERE clause to indicate a left join.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk  = t2.c_customer_sk(+) 
order by 1 desc limit 1;
 sr_item_sk | c_customer_id
------------+---------------
      18000 |
(1 row)

-- Specify the operator (+) in the WHERE clause to indicate a right join.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk(+)  = t2.c_customer_sk 
order by 1 desc limit 1;
 sr_item_sk |  c_customer_id
------------+------------------
            | AAAAAAAAJNGEBAAA
(1 row)

-- Specify the operator (+) in the WHERE clause to indicate a left join and add a join condition.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk  = t2.c_customer_sk(+) and t2.c_customer_sk(+) < 1 order by 1  limit 1;
 sr_item_sk | c_customer_id
------------+---------------
          1 |
(1 row)

-- If the operator (+) is specified in the WHERE clause, do not use expressions connected through AND/OR.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where not(t1.sr_customer_sk  = t2.c_customer_sk(+) and t2.c_customer_sk(+) < 1);
ERROR:  Operator "(+)" can not be used in nesting expression.
LINE 1: ...tomer_id from store_returns t1, customer t2 where not(t1.sr_...
                                                             ^
-- If the operator (+) is specified in the WHERE clause which does not support expression macros, an error will be reported.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where (t1.sr_customer_sk  = t2.c_customer_sk(+))::bool;
ERROR:  Operator "(+)" can only be used in common expression.

-- If the operator (+) is specified on both sides of an expression in the WHERE clause, an error will be reported.
postgres=# select t1.sr_item_sk ,t2.c_customer_id from store_returns t1, customer t2 where t1.sr_customer_sk(+)  = t2.c_customer_sk(+);
ERROR:  Operator "(+)" can't be specified on more than one relation in one join condition
HINT:  "t1", "t2"...are specified Operator "(+)" in one condition.

-- Delete the table.
postgres=# DROP TABLE tpcds.reason_p;
```

